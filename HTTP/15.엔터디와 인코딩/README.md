이 글은 'HTTP 완벽가이드'라는 책을 읽으면서 제가 이해한 내용을 바탕으로 정리한 글입니다. 
혹시 이 글을 보게 되신다면 비판적인 시각으로 보시는 것을 추천 드립니다.

<img src="http://image.yes24.com/goods/15381085/XL" alt="HTTP 완벽 가이드" style="zoom:67%;" />

---

## 엔터티와 인코딩

- HTTP는 메시지가 올바르게 수송되고, 식별되고, 추출되고, 처리되는 것을 보장
  - 객체는 올바르게 식별되므로(Content-Type 미디어 포맷과 Content-Language 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리가능
  - 객체는 올바르게 압축이 풀림
  - 객체는 항상 최신
  - 사용자의 요구를 만족함
  - 네트워크 사이를 빠르고 효율적으로 이동
  - 조작되지 않고 온전하게 도착







### 1. 메시지는 컨테이너, 엔티티는 화물

- Content-Type
  - 엔터티에 의해 전달된 객체 종류
- Content-Length
  - 전달되는 메시지의 길이나 크기
- Content-Language
  - 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding
  - 객체 데이터에 대해 행해진 변형
- Content-Location
  - 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range
  - 만약 이 엔터디가 부분 엔터디라면, 이 헤더는 엔터티가 전체에서 어느 부분에 해당하는지 정의
- Content-MD5
  - 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified
  - 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires
  - 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow
  - 이 리소스에 대해 어떤 요청 메서드가 허용되는지
- ETag
  - 이 인스턴스에 대한 검사기
  - ETag 헤더는 엔터티 헤더로 정의되지 않았지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더
- Cache-Control
  - 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자



#### 1. 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고있음
- 다른 정보들은 모두 헤더에 포함
- 엔터티 본문은 빈 CLEF 줄 바로 다음부터 시작



### 2. Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄
- 어떻게 인코딩 되었든 상관없이 크기를 표현(압축된 후의 크기)
- Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에 필수적으로 있어야함
- 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요



#### 1. 잘림 검출

- Content-Length가 없다면 클라이언트 커넥션이 정상적으로 닫힌 것인지 충돌한 것인지 구분할 수 없음
- 클라이언트는 메시지 잘림을 검출하기 위해 Content-Length가 필요
- 특히, 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못했다면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공한다



#### 2. Content-Length와 지속 커넥션

- Content-Length는 지속 커넥션을 위해 필수다.
- 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것.
- Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌



#### 3. 콘텐츠 인코딩

- HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩 할 수 있게 해줌
- 본문의 콘텐츠가 인코딩되어 있다면, Content-Length헤더는 인코딩 된 본무의 길이를 바이트 단위로 정의
  - HTTP 애플리케이션은 이것을 잘못해서 인코딩 전의 크기를 보내는 것으로 알려져 있는데, 지속 커넥션일 때 심각한 오류를 유발



#### 4. 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시
2. HEAD 메서드는 GET 요청을 보냈다면 받게 될 응답에서 본문은 제외하고 헤더들만 보내라고 서버에 요청
3. 만약 Content-Length 헤더 필드와 identity가 아닌 Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 받았다면 반드시 Content-Length 헤더를 무시함
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터디 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것. 이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형
5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남





### 3. 엔터티 요약

- HTTP가 일반적으로 TCP/IP와 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구, 여러가지 이유로 메시지 일부분이 변형되는 문제 발생
- 이를 위해 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 검사
- Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과을 보내기 위해 사용
- 응답을 처음 만든 서버만이 Content-MD5 헤더를 계선하새 보냄
  - 콘텐츠 인코딩의 적용은 끝났지만 전송 인코딩은 아직 적용하지 않은 엔터티 본문에 대한 MD5를 담고 있음
  - 메시지 무결성을 검증하려는 클라이언트는 먼저 전송 인코딩을 디코딩한 뒤 그 디코딩 된 엔터티 본문에 대해 MD5를 계싼
- 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용
- **하지만 Content-MD5 헤더는 그다지 자주 전송되지 않음**



### 4. 미디어 타입과 차셋

- Content-Type 헤더 필드는 엔터티본문의 MIME 타입을 기술
- MIME 타입은 전달되는 데이터 메체의 기저형식의 표준화된 이름
- MIME 타입은 주 미디어 타입으로 시작해서 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성

| 타입          | 설명                                                         | 일반적인 서브타입 예시                                       |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `text`        | 텍스트를 포함하는 모든 문서를 나타내며 이론상으로는 인간이 읽을 수 있어야 합니다 | `text/plain`, `text/html`, `text/css, text/javascript`       |
| `image`       | 모든 종류의 이미지를 나타냅니다. (animated gif처럼) 애니메이션되는 이미지가 이미지 타입에 포함되긴 하지만, 비디오는 포함되지 않습니다. | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp` |
| `audio`       | 모든 종류의 오디오 파일들을 나타냅니다.                      | `audio/midi`, `audio/mpeg, audio/webm, audio/ogg, audio/wav` |
| `video`       | 모든 종류의 비디오 파일들을 나타냅니다.                      | `video/webm`, `video/ogg`                                    |
| `application` | 모든 종류의 이진 데이터를 나타냅니다.                        | `application/octet-stream`, `application/pkcs12`, `application/vnd.mspowerpoint`, `application/xhtml+xml`, `application/xml`, `application/pdf` |

1. **텍스트 매체를 위한 문자 인코딩**

   - Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원
   - 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매게변수가 대표적인 그 예

   ```
   Content-Type : text/html; charset=iso-8859-4
   ```

2. **멀티파트 미디어 타입**

   - MIME "멀티파트" 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐

3. **멀티파트 폼 제출**

   - HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐
   - 여러 다른 종류의 길이의 값으로 채워진 폼을 허용함



### 5. 콘텐츠 인코딩

- HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 함
- 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 압축을 할 수 있음

1. **콘텐츠 인코딩 유형**
   - Content-Encoding 헤더는 이러한 표준화된 토큰 값을 이용해서, 인코딩에 사용된 알고리즘들에 기술
   - gzip은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘
2. **Accept-Encoding 헤더**
   - 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달



### 6. 전송 인코딩과 청크 인코딩

- 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있음
  - 텍스트 파일은 흔히 gzip으로 압축하지만, JPEG 파일은 그렇게 하지않음
- 전송 인코딩 또한 엔터디 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠 포맷과는 독립적

1. **Transfer-Encoding 헤더**
   - 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 두개이다
   - Transfet-Encoding
     - 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줌
   - TE
     - 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용
2. **청크 인코딩**
   - 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갬
   - 서버는 각 청크를 순차적으로 보냄
   - 청크인코딩은 전송 인코딩의 한 형태. 멀티파트 인코딩은 본문의 속성이기 때문에 청크인코딩과는 별개임

- **청크와 지속 커넥션**

  - 클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없음.

  - 지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문 길이를 담아서 보내야 함
    - 콘텐츠가 동적으로 생성되는 경우 본문의 길이를 알 수 없는 경우가 생ㄱ김

  - 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해범 제공
    - 일정한 크기의 정크로 본문을 보냄
      - 크기가 0인 청크를 보냄으로써 본문의 끝을 알림

- **콘텐츠와 전송 인코딩의 조합**
  - 콘텐츠 인코딩을 사용해 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송하는 묘사를 함



3. 전송 인코딩 규칙
   - 전송 인코딩의 집합은 반드시 'chunked'를 포함해야함
   - 청크 전송 인코딩이 사용됐다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야함
   - 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용 되어야 함



### 7. 검사기와 신선도

- 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청



#### 1. 신선도

- 서버는 Expires나 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있음
- Expires 헤더를 바르게 사용하는 클라이언트나 헤더는, 그들의 시계를 반드시 동기화 함
- 이런 이유로 상대시간을 이용해 만료를 정의하는 메커니즘이 많이 사용됨
  - Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터 총 시간을 초 단위로 정함

#### 2. 조건부 요청과 검사기

- 캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들어야 함
- 캐시의 사본과 원서버의 내용이 같은 경우에도 캐시가 이러한 요청을 한다면 자원 낭비가 일어남.
  - 이를 위해 HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 방법 제공
  - 특정 조건이 참일 때만 수행하며 'if-로 시작하는 헤더에 의해 구현
- HTTP는 약한검사기와 강한 검사기 두가지로 분류
  - 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우가 있음
    - 바이트 단위 크기, 최종 변경시각이 약한 리소스에 해당
  - 강한 검사기는 언제나 고유하게 식별
    - ETag 헤더는 강한 검사기로 간주되는데, 서버는 ETag 헤더에 매 변경마다 구분되는 값을 넣어둠



### 8. 범위 요청

- 범위 요청을 이용하면, HTTP  클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있음



### 9. 델타 인코딩

- 새 페이지 전체를 보내는 대신, 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만을 서버가 보낸다면 클라이언트는 더 빨리 페이지를 얻을 수 있음
- 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 최적화함
- 클라이언트는 서버에게 A-IM과 같은 헤더를 보내 자신이 델타를 받아들일 수 있음을 알려줄 수 있음
- 델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 까다로움
- 자신이 제공하는 페이지가 변경되는데 매 순간의 사본을 모두 유지하고 있어야 함
- 문서를 제공하는데 걸리는 시간이 줄어드는 대신, 서버는 문서의 과거 사본을 모두 유지하기 위해 디스크 공간을 늘려야함





