이 글은 'HTTP 완벽가이드'라는 책을 읽으면서 제가 이해한 내용을 바탕으로 정리한 글입니다. 
혹시 이 글을 보게 되신다면 비판적인 시각으로 보시는 것을 추천 드립니다.

<img src="http://image.yes24.com/goods/15381085/XL" alt="HTTP 완벽 가이드" style="zoom:67%;" />

---

## 다이제스트 인증

### 1. 다이제스트 인증의 개선점

- 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다
  - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않음
  - 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단
  - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능
  - 그 외 몇몇 잘 알려진 형태의 공격을 막음
- 가장 안전한 프로토콜은 아님
  - 전송 계층 보안과 SSL 보안이 더 강력
  - 실제로 현재 많이 사용되지 않음



1. **비밀번호를 안전하게 지키기 위해 요약 사용**
   - 비밀번호를 보내는 대신 비밀번호를 비가역적으로 뒤섞은 '지문' 혹은 '요약'을 보냄
2. **단방향 요약**
   - 요약은 '정보 본문의 압축'
   - 단방향 함수로 동작하며, 입력 가능한 무한 가지의 모든 값들을 유한한 범위의 압축으로 변환
     - MD5는 가장 인기있는 요약 함수로 어떤 길이의 배열이든 128비트 요약으로 변환
3. **재전송 방지를 위한 난스(nonce) 사용**
   - 단방향 요약은 악의적인 집단의 해독을 방해한다. 하지만 비밀번호를 모른다고 해도 요약을 가로 챌 경우 재전송 공격을 당할 수 있음
   - 재전송 공격을 막기 위해 난스라고 불리는 증표를 클라이언트에게 보내주고 클라이언트는 이 난스를 비밀번호에 섞음
   - 다이제스트 인증은 난스 사용을 요구하는데 위와 같은 재전송 공격을 막을 수 있음



### 2. 요약계산

1. **사전 인가**
   - 만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있어서, 서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면,  요청 / 인증 요구 사이클은생략 할 수 있음
   - 다이제스트 인증은 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇 가지 방법 제안
     - 서버가 다음 Authentication-info 성공 헤더에 담아서 미리 보냄
     - 서버가 짧은 시간 동안 같은 난스 재사용을 허용
     - 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘 사용
   - **다음 난스 미리 생성 하기**
     - 주어진 다음 난스로 클라이언트는 Authorization 헤더를 미리 만들 수 있고 요청 / 인증요구 사이클에서 벗어날 수 있지만 파이프라이닝 능력은 떨어진다 (다음 요청을 위해 난스를 기다려하기 때문)                                                                                                                                           
   - **제한된 난스 재사용**
     - 클라이언트는 난스를 미리 알 수 있으므로 자유롭게 Authorization헤더와 함께 요청을 발행하며 파이프라이닝
2. **상호 인증**
   - RFC2067 은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장



### 3. 실제 상황에 대한 고려

1. **다중 인증요구**
   - 서버는 한 리소스에 대해 여러 인증을 요구할 수 있음
   - 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야함
   - 사용자 에이전트는 WWW-Authenticate나 Proxy-Authenticate 헤더 필드의 값을 분석할 때 반드시 주의를 기울여야 함
2. **오류 처리**
   - 다이제스트 인증에서, 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있는 경우 알맞은 응답은 400 Bad Request이다.
3. **보호 공간**
   - 보호 공간은 어떤 자격이 자동으로 적용되는 영역을 결정
     - 기본 인증에서, 클라이언트는 요청 URI와 그 하위의 모든 경로는 같은 보호 공간에 있는 것으로 가정
     - 다이제스트 인증에서 WWW-Authenticate : domaion 필드는 보호 공간을 엄밀하게 정의
4. **캐시**
   - 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안됨
     - 원 서버의 응답이 "must-revalidate" Cache-Control 지시자를 포함한 경우 캐시는 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용
     - "public" Cache-Control 지시자를 포함한 경우, 응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환



### 4. 보안에 대한 고려 사항

1. 재전송 공격

   - 유일한 난스 값을 사용할 경우 재전송 공격에 취약해짐

2. 다중 인증 메커니즘

   - 클라이언트에게 가장 강력한 인증 메커니즘을 선택할 의무 사항이 없음. 즉, 가장 약한 선택지가 인증의 강도가 됨
   - 이 문제를 필요하기 위해 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하는 방법이 있음

3. 악의적인 프락시와 중간자 공격

   - 프락시 중 하나가 악의적이거나 보안이 허술하다면 클라이언트 중간자 공격에 취약한 상태가 될 가능성이 있음
   - 이 문제를 해결하기 위해서는 SSL을 사용하는 것이 좋음

   



