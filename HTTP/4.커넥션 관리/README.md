이 글은 'HTTP 완벽가이드'라는 책을 읽으면서 제가 이해한 내용을 바탕으로 정리한 글입니다. 
혹시 이 글을 보게 되신다면 비판적인 시각으로 보시는 것을 추천 드립니다.

<img src="http://image.yes24.com/goods/15381085/XL" alt="HTTP 완벽 가이드" style="zoom:67%;" />

---



## 커넥션 관리

- 학습내용
  - HTTP는 어떻게 TCP 커넥션을 사용하는가
  - TCP 커넥션의 지연, 병목, 막힘
  - 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
  - 커넥션 관리를 위해 따라야 할 규칙들



### 1. TCP 커넥션

- 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 토해 이루어짐
- 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP커낵션을 맺을 수 있음

1.  신뢰할 수 있는 데이터 전송 통로인 TCP

   - TCP 커넥션은 인터넷을 안정적으로 연결해줌
   - HTTP에게 신뢰할 만한 통신 방식을 제공

2. TCP 스트림은 세그먼트로 나뉘어 IP패킷을 통해 전송

   ![img](https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1631952600/tlog/Untitled-e70b9b38-476b-494c-bdb4-8b03e70e78b1_xokqzy.png)

   - TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송
   - HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냄
   - 세그먼트 단위로 데이터 스트림을 잘게 나구고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아 인터넷을 통해 전달

3. TCP 커넥션 유지

   - 컴퓨터는 항상 여러개의 커넥션을 가짐

   - TCP는 포트 번호를 통해 커넥션 유지

   - TCP 커넥션은 아래 네가지 값으로 식별

     ```
     <밣신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>
     ```

   - 네가지 커넥션 구성요소를 모두 똑같이 가리킬 수는 없음

4. TCP 소켓 프로그래밍

   - 운영체제 차원에서 TCP 커넥션 관련 기능 제공

   ![img](https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1631952600/tlog/Untitled-e8a43434-de05-42ae-a7e6-d0e0f1c70767_a3ubjf.png)

   



### 2. TCP 성능에 대한 고려

- HTTP 는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받음

#### 1. HTTP 프로그래머에게 영향을 주는 일반적인 TCP 관련 지연

- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
- 데이터를 한데 모아 한번에 전송하기 위한 네이글알고리즘
- TCP의 편승 / 확인응답을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈



#### 2. TCP 커넥션 핸드셰이크 지연

- 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 면, TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환함

- 작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환은 HTTP 성능을 크게 저하 시킬 수 있음

- TCP 커넥션 핸드셰이크 순서

  ​	![img](https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1631952597/tlog/Untitled-aa9ae9c8-fa94-4403-be3b-b2f984418214_dbk28v.png)

  - 클라이언트는 새로운 TCP 커넥션 생성을 위해 작은 TCP 패킷을 서버에게 보냄. 이 과정에서 DNS 이름 분석 인프라를 사용하여 URL에 있는 호스트 명을 IP 주소로 변환하는데 시간이 걸림
  - 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출, 커넥션 요청이 받아졌음을 의미하는 'SYN', 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보냄
  - 마지막 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에게 다시 확인응답 신호를 보냄. 오늘날의 TCP는 클라이언트가 이 확인응답 패킷과 함께 데이터를 보내기도 함

- HTTP 트랜잭션이 아주 큰 데이터를 주고받지 않는 평범한 경우에는 SYN/SYN-ACK 핸드셰이크가 눈에 띄는 지연을 발생 시킬 수 있음



#### 3. 확인응답 지연

- TCP는 성공적인 데이터 전송을 보장하기 위해 자체적인 확인 체계를 가짐
- TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가짐. 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 반환
- 확인응답은 크기가 작기 떄문에, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 '편승'시킴
- 하지만, 편승할 패킷을 찾는 과정에서 확인응답 지연으로 인한 지연이 자주 발생



#### 4. TCP 느린 시작

- TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높여 나감
- TCP 느린 시작은 TCP가 한번에 전송할 수 있는 패킷의 수를 제한
- 갑작스러운 부하와 혼잡을 방지하는데 쓰이지만 지연을 발생시킬 수 있음
- 이를 해결하기 위해 커넥션을 계속 사용하는 '지속 커넥션'사용



#### 5. 네이글 알고리즘

- TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크 성능이 떨어 질 수 있음

- 네이글 알고리즘은 네트워크 효율을 위해, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합침

- 네이글 알고리즘의 문제점

  1. 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에, 추가적인 데이터를 기다리며 지연
  2. 확인응답 지연과 함께 쓰일경우 문제발생
     - 네이글 알고리즘은 확인 응답이 도착할 때 까지, 데이터 전송을 멈추고 있지만 확인응답 지연은 확인응답을 편승시킬 패킷을 찾으며 지연 시킴

  3. HTTP 스택에 TCP_NODELAY 파라미터 값을 설정한다면 네이글 알고리즘을 비활성화 할 수 있음
     - 이 방법을 이용한다면 작은 크기의 패킷이 너무 많이 생성되지 않도록 해야함



#### 6. TIME_WAIT 누적과 포트 고갈

- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP주소와 포트번호를 메모리의 작은 영역에 기록함
- 이 정보는 같은 주소와 포트번호를 사용하는 새로운  TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위해 사용
  - 보통 세그먼트 최대 생명주기에 두배정도('2MSL'이라 불림)의 시간 동아 유지(2분)
- 현대의 빠른 라우터들 덕분에 커넥션이 닫힌 후에 중복되는 패킷이 생기는 경우는 없어짐.
- 만약 같은 값으로 커넥션에 삽입되면 패킷이 중복되고 TCP데이터가 충돌 되는 문제 발생



### 3. HTTP 커넥션 관리

1. 흔히 잘못 이해하는 Connection 헤더
   - 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면, 해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안됨
   - Connection헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 함
   - Connection 헤더는 홉별(hop-by-hop) 헤더 명을 기술하는데, 이것을 '헤더 보호하기'라고 함
2. 순차적인 트랜잭션 처리에 의한 지연
   - 커넥션 관리가 제대로 이루어 지지 않으면 TCP 성능이 안좋아 질 수 있음
   - 이를 위한 해결 법
     - 병렬 커넥션
     - 지속 커넥션
     - 파이프라인 커넥션
     - 다중 커넥션(실험중인 기술)

#### 1. 병렬 커넥션

- HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리

- 병렬 커넥션은 페이지를 더 빠르게 내려받음
- 상황에 따라 항상 더 빠르지는 않지만, 화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있으면, 그것을 더 빠르다고 여김



#### 2. 지속 커넥션

- 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션
- TCP의 느린 시작으로 인한 지연을 피할 수 있음



1. 지속 커넥션 VS 병렬 커넥션

   1. 병렬 커넥션의 단점
      - 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭 소요
      - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능 저하
      - 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음
   2. 지속 커넥션의 장점
      - 사전 작업과 지연을 줄여줌
      - 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여줌
   3. 현대의 애플리케이션은 적은 수의 병렬 커넥션을 유지하고 있음

2. HTTP/1.0 의 Keep-AlIVE 커넥션

   - HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 keep-alive 헤더를 사용함

   ```
   Connection: Keep-Alive
   
   Keep-Alive: max=5, timeout=120
   ```

   - 멍청한 프락시
     - 서버가 keep-alive를 지원한다면 Connection:keep-alive를 응답에 포함할 것이고, 지원하지 않으면 포함하지 않음
     - 하지만 멍청한 프락시는 Connection 헤더를 이해하지 못하고 해당 헤더를 그대로 다음 프락시로 전달 (hop-by-hop 전략에 의해 삭제 되어야함)
     - 서버와 클라이언트는 Connection:keep-alive 헤더가 전달되어 연결이 끊기지 않은 줄 알지만, 프락시는 다른 요청이 또 올 수 있다는 것을 예상하지 않기 때문에 요청을 무시함
   - 프락시와 홉별 헤더
     - 이런 문제를 해결하기 위해 프락시는 Connection 헤더를 전달하면 안됨
     - 이를 위해 Proxy-Connection 헤더를 개발하며 프락시가 이 헤더를 받은 경우 Connection 헤더를 다음 프락시에게 전달하도록 함
     - 만약 여러개의 프락시가 존재하는 경우에는 이런 문제를 해결 할 필요가 있음

3. HTTP/1.1의 지속 커넥션

   - HTTP/1.1에서는 keep-alive 대신 개선된 지속 커넥션 지원
   - 1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급

4. 지속 커넥션의 제한과 규칙

   - 클라이언트가 Connection : close를 헤더에 보낸다면 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음
   - 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션 지속 가능

#### 3. 파이프라인 커넥션

- 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있음
- 영속적인 커넥션을 통해서, 응답을 기다리지 않고 요청을 연속적으로 보내는 기능
- 파이프라인 제약사항
  - 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안됨
  - HTTPM 응답은 요청 순서와 같게 와야 함
  - 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 수 있어야 함
  - 즉 실패했을 때 문제가 없는 (GET, HEAD, PUT)과 같은 메서드로만 해야함
    - POST와 같은 메서드는 실패 후 재 실행시 문제 여지가 많음



